( Nasforth extensions for Polydos - Bob Edwards 1983, 2023 )( Whereas Nasforth v1.11 used a RAM disk for source code )( this version uses the Polydos disk drive )( word WARM is used to set this up )HEX( A CELL is the data size needed to define a compiled forth word )( returns number of bytes per word ): CELL  ( -- n )    2;: CELLS ( n -- n x CELL )    CELL *;: CELL+ ( n -- n + CELL )    CELL +;( CPU clock utilities )( Set the Z80 clock to 19.5MHz, adjust cursor blink and autorepeat ): FAST  ( -- )1800 C202 !600 C204 !3 C201 C!C00 C32 !3C0 C30 !1E00 C2E !3 1A P!;FAST( Set the Z80 clock to 4MHz, reset cursor blink and autorepeat ): SLOW  ( -- )200 C202 !80 C204 !C0 C201 C!100 C32 !50  C30 !280 C2E !20 1A P!;( If f=true echo Nascom screen to the serial port, else turn serial echo off ): SERECHO   ( f -- )IF    0774 C73 !ELSE    0779 C73 !THEN;( if f=true listen to serial in as well as keyboard )( else listen to keyboard only ): SERLISTEN     ( f -- )IF    D428 C75 !ELSE    0780 C75 !THEN;FAST 1 SERECHO( Switch TAPE led on and off as fast as can be ): OSC   ( -- )BEGIN       10 1A P!    0 1A P!AGAIN;FORTHHEXC29 CONSTANT CURSORC414 CONSTANT NXTSECC001 CONSTANT DDRVC300 CONSTANT SECBUFDECIMAL56 USER TOP58 USER BOTTOM: NUMIN                 ( --- NUMERIC INPUT ) CR ." ?" QUERY 1 WORD HERE NUMBER DROP ;( VOCABULARY TEST IMMEDIATE )( TEST DEFINITIONS )HEX5BDF 121B !             ( 'BYE' NOW RETURNS TO POLYDOS, NOT NASSYS )14E6 218A !             ( CORRECTS +- MISDEF. ): BYE                   ( -- )    FLUSH BYE           ( ENSURE ALL NEW EDITS ARE SAVED TO DISK BEFORE EXIT );DECIMAL : 1- 1 - ;: STRING  <BUILDS DUP C, 0 C, ALLOT  DOES> 2+ DUP 1- C@ ;: CLR$  DROP DUP 1- DUP 0 SWAP C! 1- C@ 32 FILL ;: INPUT$  DROP 1- DUP 1- C@ CR ." ? "  QUERY  1 WORD HERE C@ < IF ." String too big "  DROP QUIT THEN HERE DUP C@ 1+ ROT SWAP  CMOVE ; HEX C055 CONSTANT S1FCB  DECIMAL  ( file control block pointers ) : FNAM 0 + ;                ( filename ): FEXT 8 + ;                ( file extension ): FSFL 10 + ;               ( system flags ): FUFL 11 + ;               ( user flags ): FSEC 12 + ;               ( sector address ): FNSC 14 + ;               ( length in sectors ): FLDA 16 + ;               ( load address ): FEXA 18 + ;               ( execute address )( Polydos system calls )( RETURN DISK SIZE IN SECTORS )CODE DSIZE              ( DRIVE NO. --- DISCSIZE TRUE )                        (      OR   --- ERRORNO. FALSE ) I' W' MOV I W MOV      ( SAVE BC IN DE ) I POP                  ( GET DRIVE NUMBER ) 3 RST HEX 80 C,        ( SCAL ZDRD ) 0= IF                  ( IF NO ERROR ) H PUSH H PUSH          ( DISCSIZE + TRUE FLAG ) ELSE A L MOV 0 H MVI        ( RETURN ERROR CODE ) H PUSH 0 L MVI H PUSH  ( & FALSE FLAG ) THEN W' I' MOV W I MOV      ( RESTORE BC ) NEXT JMPEND-CODE( READ SECTORS )CODE DRD                ( MEMADDR DISCADDR SECTORNO DRIVENO )                        ( --- STATUS, 0 MEANS OK ) I PUSH IX POP          ( SAVE BC IN IX ) I POP                  ( C= DRIVE NO ) H POP L I MOV          ( B= NO OF SECTORS ) W POP H POP            ( DE= DISCADDR, HL= MEM ) 3 RST HEX 81 C,        ( SCAL ZDRD ) 0 H MVI A L MOV        ( HL= STATUS ) H PUSH IX PUSH I POP          ( RESTORE BC ) NEXT JMPEND-CODE( WRITE SECTORS ) CODE DWR                ( MEMADDR DISCADDR SECTORNO DRIVENO )                        ( --- STATUS, 0 MEANS NO ERROR ) I PUSH IX POP I POP H POP L I MOV W POP H POP 3 RST HEX 82 C, 0 H MVI A L MOV H PUSH IX PUSH I POP NEXT JMPEND-CODE( READ DIRECTORY )CODE RDIR               ( DRIVENO --- STATUS ) H POP                  ( GET DRIVE NUMBER ) I PUSH                 ( SAVE BC ) L I' MOV               ( DRIVE NUMBER IN C ) 3 RST HEX 83 C,        ( SCAL ZRDIR ) 0 H MVI A L MOV        ( STATUS CODE IN HL ) I POP                  ( RESTORE BC ) HPUSH JMP              ( RETURN WITH STATUS ON STACK )END-CODE( WRITE DIRECTORY )CODE WDIR               ( --- STATUS ) 3 RST HEX 84 C,        ( SCAL ZWDIR ) 0 H MVI A L MOV HPUSH JMP              ( RETURN WITH STATUS ON STACK )END-CODE( CONVERT FILE SPECIFIER )CODE CFS                ( FCBADDR TEXTADDR FLAGS --- )                        ( FCBADDR TEXTADDR' DRIVENO FLAGS' ERRORCODE ) I PUSH IX POP          ( BC SAVED IN IX ) I POP I' I MOV         ( B=FLAGS) W POP H POP            ( DE=TEXTADDR, HL=FCBADDR ) 3 RST HEX 85 C, ( SCAL ZCFS ) H PUSH W PUSH I' L MOV 0 H MVI H PUSH ( DRIVE NUMBER ) I I' MOV H I MOV I PUSH ( RESULT FLAG ) A I' MOV I PUSH         ( ERROR CODE ) IX PUSH I POP NEXT JMPEND-CODE( LOOKUP FILE IN DIRECTORY )CODE LOOK               ( FCBADDR OLDFCBADDR FLAGS --- )                        ( FCBADDR NEWFCBADDR FLAGS' STATUS ) I PUSH IX POP          ( SAVE BC IN IX ) I POP I' I MOV         ( B=FLAGS ) W POP H POP            ( DE=PREVIOUS MATCH FCB )                        ( HL=LOOKUP FCB ) 3 RST HEX 86 C,        ( SCAL ZLOOK ) H PUSH W PUSH I I' MOV 0 I MVI I PUSH ( FLAGS' ) A I' MOV I PUSH        ( ERROR CODE ) IX PUSH I POP          ( RESTORE BC ) NEXT JMPEND-CODE( ENTER FCB INTO DIRECTORY )CODE ENTER              ( FCB --- FCB' STATUS ) H POP                  ( HL= FCB ADDRESS ) 3 RST HEX 87 C,        ( SCAL ZENTER ) W PUSH                 ( SAVE FCB' ) A W' MOV 0 W MVI W PUSH ( STATUS SAVE ) NEXT JMPEND-CODE( CALL AN OVERLAY )CODE COV                ( OVERLAYNAMEADDR --- ) HEX H POP              ( GET STRING ADDR ) I PUSH                 ( SAVE BC ) HERE 0A + W LXI        ( DESTINATION ) 4 I LXI                ( NAME LENGTH= 4 ) LDIR                   ( COPY ACROSS ) 3 RST 88 C,            ( SCAL ZCOV ) NOP NOP NOP NOP        ( NAME SPACE ) I POP NEXT JMPEND-CODE( CALL AN OVERLAY AND RESTORE )CODE COVR               ( OVERLAYNAMEADDR --- ) HEX H POP              ( GET STRING ADDR ) I PUSH                 ( SAVE BC ) HERE 0A + W LXI        ( DESTINATION ) 4 I LXI                ( NAME LENGTH= 4 ) LDIR                   ( COPY ACROSS ) 3 RST 89 C,            ( SCAL ZCOVR ) NOP NOP NOP NOP        ( NAME SPACE ) I POP NEXT JMPEND-CODE( CHECK FOR A SYSTEM ERROR )CODE CKER               ( ERROR CODE --- ) H POP L A MOV          ( A= ERROR CODE ) I PUSH 3 RST HEX 88 C,        ( SCAL ZCOVR ) DECIMAL 69 C, 109 C, 115 C, 103 C, ( Emsg ) I POP NEXT JMPEND-CODE( OUTPUT CHAR TO PRINTER )CODE POUT               ( CHARACTER --- ) H POP L A MOV          ( A = CHAR ) I PUSH 3 RST HEX 8F C,        ( SCAL ZPOUT ) I POP NEXT JMPEND-CODE( TRADITIONAL FORTH SCREEN SUPPORT ENCASED IN A POLYDOS DISK FILE )DECIMAL14 STRING FILENAME: NOERROR  SWAP -DUP  IF        CR CKER CR 0        DO            DROP        LOOP 0  ELSE        DROP 1  THEN ;( ADR - SOURCE OR DEST BLOCK ON DISK, BLK - REFERENCE BLOCK IN RAM, FLAG=0 WRITE, FLAG=1 READ ): NEWR/W    ( ADR BLK FLAG -- )  >R                                    ( SAVE THE FLAG )                                     2 /MOD BOTTOM @ +                     ( CALCULATE THE REQD SECTOR ON DISK )   DUP  TOP @ SWAP U< 6 ?ERROR                ( CHECK IT'S NOT PAST END OF FILE )  DUP SECBUF SWAP 1 DDRV C@ DRD CKER    ( READ THE REQD SECTOR INTO RAM )     R>                                    ( REINSTATE FLAG )  IF                                    ( IF READING FROM DISK )       DROP SECBUF SWAP        IF             B/BUF +       THEN       SWAP B/BUF CMOVE  ELSE                                  ( ELSE IF WRITING TO DISK )       >R SECBUF SWAP        IF            B/BUF +       THEN       B/BUF CMOVE       SECBUF R> 1 DDRV C@ DWR CKER  THEN ;( SET TOP & BOTTOM AS 1ST AND LAST DISK SECTOR ADDRESSES ): TBSET   ( -- )                S1FCB DUP FSEC @ BOTTOM !           ( BOTTOM = START SECTOR OF FILE )  FNSC @ BOTTOM @ + TOP !            ( TOP = END SECTOR OF FILE )  ' NEWR/W CFA 'R/W ! ;                 ( REDIRECT ALL FURTHER I/O TO DISK ): FILE                  ( -- )  BEGIN   BEGIN    BEGIN     S1FCB FILENAME CLR$ ." Enter file name"     FILENAME INPUT$ FILENAME DROP 6 CFS     4 NOERROR    UNTIL    DROP 20294 S1FCB FEXT !           ( SET THE FILE EXTENSION TO .FO )    RDIR                                ( READ DIR )    2 NOERROR   UNTIL   16 LOOK   3 NOERROR  UNTIL  DROP DROP DROP   TBSET ;  : NEWFILE               ( -- )  BEGIN   BEGIN    BEGIN     S1FCB FILENAME CLR$ ." Enter file name"     FILENAME INPUT$ FILENAME DROP 6 CFS     4 NOERROR    UNTIL    DROP 20294 S1FCB FEXT !           ( SET FILE EXTENSION TO .FO )    RDIR 2 NOERROR                      ( READ DIR )   UNTIL   0 S1FCB FSFL !   NXTSEC @ S1FCB FSEC !   BEGIN    CR ." Enter number of screens ( "    DDRV C@ DSIZE DROP NXTSEC @ - 4 / DUP 1- .    ." maximum )"    NUMIN DUP 4 * S1FCB FNSC ! SWAP U<   UNTIL   DROP ENTER 1 NOERROR  UNTIL DROP  TBSET ;FORTH DEFINITIONSDECIMAL( Displays user choice to select existing 'forth disk' or create new one )( The file contains a fixed number of 'screens' accessed )( via the traditional forth line editor ) : WARM  ( -- )FLUSH 12 EMIT10 SPACES ." Disc Forth 1.1"CR CR ." Memory Free " FREE CR CR." Enter required option, 1 or 2" CR CR." 1) Create New Disc File" CR." 2) Access Existing File" CR CRNUMIN 2 = IF FILE ELSE NEWFILE THENEMPTY-BUFFERS."  File " FILENAME TYPE ."  now active" CR;